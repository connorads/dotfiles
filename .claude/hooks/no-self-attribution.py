#!/usr/bin/env python3
"""
Claude Code hook to strip self-attribution patterns from git commits and GitHub PRs/issues.

Strips specific attribution patterns while allowing legitimate mentions of "Claude".
Uses the updatedInput mechanism to clean commands and allow them through.

Exit codes:
  0 - Always (stripped or pass-through)

Output:
  JSON with updatedInput when stripping was applied, nothing otherwise.

Tests: uv run --with pytest pytest ~/.claude/hooks/test_no_self_attribution.py -v
"""

from __future__ import annotations

import json
import re
import sys
from pathlib import Path

# Patterns that indicate self-attribution in commits
COMMIT_PATTERNS = [
    r"Co-Authored-By:.*[Cc]laude",
    r"Co-Authored-By:.*[Aa]nthropic",
    r"Co-Authored-By:.*noreply@anthropic",
]

# Patterns that indicate self-attribution in PRs/issues
GH_PATTERNS = [
    r"Generated with.*Claude",
    r"Generated by Claude",
    r"\U0001F916.*Claude Code",  # Robot emoji
]


def _strip_lines_matching(text: str, patterns: list[str]) -> str:
    """Remove lines matching any pattern from multiline text, strip trailing blank lines."""
    lines = text.split("\n")
    filtered = [
        line
        for line in lines
        if not any(re.search(p, line, re.IGNORECASE) for p in patterns)
    ]
    # Strip trailing blank lines
    while filtered and filtered[-1].strip() == "":
        filtered.pop()
    return "\n".join(filtered)


def _strip_lines_matching_in_command(command: str, patterns: list[str]) -> str:
    """Strip matching lines from inline message text in a command.

    Handles both literal '\\n' (two chars, used in -m "...") and real newlines (heredocs).
    Also handles single-line commands where the entire value matches a pattern.
    """
    modified = command
    # Handle literal \n (two-char sequences in -m "..." args)
    for pattern in patterns:
        if "\\n" in modified:
            parts = modified.split("\\n")
            parts = [p for p in parts if not re.search(pattern, p, re.IGNORECASE)]
            # Strip trailing empty parts
            while parts and parts[-1].strip() in ("", '"', "'", '")'):
                if parts[-1].strip() in ('"', "'", '")'):
                    break
                parts.pop()
            modified = "\\n".join(parts)

    # Handle real newlines (heredocs)
    if "\n" in modified:
        modified = _strip_lines_matching(modified, patterns)

    # Handle single-line: remove pattern match from within quoted args
    # e.g. --body "Generated by Claude" -> --body ""
    if modified == command:
        for pattern in patterns:
            modified = re.sub(pattern, "", modified, flags=re.IGNORECASE)

    return modified


def _remove_trailer_args(command: str, patterns: list[str]) -> str:
    """Remove --trailer "Co-Authored-By: ..." flag+value pairs from a command string."""
    for pattern in patterns:
        # Match --trailer followed by a quoted value containing the pattern
        # Double-quoted: --trailer "...pattern..."
        command = re.sub(
            r'\s*--trailer\s+"[^"]*?' + pattern + r'[^"]*"',
            "",
            command,
            flags=re.IGNORECASE,
        )
        # Single-quoted: --trailer '...pattern...'
        command = re.sub(
            r"\s*--trailer\s+'[^']*?" + pattern + r"[^']*'",
            "",
            command,
            flags=re.IGNORECASE,
        )
    return command


def _clean_file(filepath: str, patterns: list[str]) -> bool:
    """Read file, strip matching lines, rewrite in-place. Return whether anything changed."""
    path = Path(filepath).expanduser()
    try:
        original = path.read_text()
    except (OSError, ValueError):
        return False

    cleaned = _strip_lines_matching(original, patterns)
    # Compare stripped versions so trailing whitespace differences don't trigger false positives
    if cleaned.rstrip() != original.rstrip():
        path.write_text(cleaned + "\n" if cleaned else "")
        return True
    return False


def _read_file_arg(command: str, flag_pattern: str) -> str | None:
    """Extract filepath from a CLI flag argument."""
    match = re.search(flag_pattern, command)
    if not match:
        return None
    return match.group(1)


# NOTE: A commit bypassed this hook in Jan 2025 â€” root cause unclear
# (conversation context was compacted). Adding -F file checks as defence in depth.


def clean_git_commit(command: str) -> str | None:
    """Clean self-attribution from a git commit command. Return cleaned command or None."""
    if not re.search(r"\b(git|dotfiles)\b.*\bcommit\b", command):
        return None

    modified = False
    cleaned = command

    # Remove --trailer args with attribution
    after_trailer = _remove_trailer_args(cleaned, COMMIT_PATTERNS)
    if after_trailer != cleaned:
        cleaned = after_trailer
        modified = True

    # Clean -F / --file referenced commit message file
    filepath = _read_file_arg(cleaned, r'(?:-F|--file)[=\s]+["\']?([^\s"\']+)')
    if filepath and _clean_file(filepath, COMMIT_PATTERNS):
        modified = True

    # Strip matching lines from inline message text
    after_strip = _strip_lines_matching_in_command(cleaned, COMMIT_PATTERNS)
    if after_strip != cleaned:
        cleaned = after_strip
        modified = True

    return cleaned if modified else None


def clean_gh_command(command: str) -> str | None:
    """Clean self-attribution from a gh command. Return cleaned command or None."""
    if not re.search(r"\bgh\s+(pr|issue)\s+(create|edit|comment)", command):
        return None

    modified = False
    cleaned = command

    # Clean --body-file referenced file
    filepath = _read_file_arg(cleaned, r'--body-file[=\s]+["\']?([^\s"\']+)')
    if filepath and _clean_file(filepath, GH_PATTERNS):
        modified = True

    # Strip matching lines from inline text
    after_strip = _strip_lines_matching_in_command(cleaned, GH_PATTERNS)
    if after_strip != cleaned:
        cleaned = after_strip
        modified = True

    return cleaned if modified else None


def main() -> int:
    try:
        input_data = json.load(sys.stdin)
    except json.JSONDecodeError:
        return 0

    tool_input = input_data.get("tool_input", {})
    command = tool_input.get("command", "")

    if not command:
        return 0

    # Try each cleaner; first match wins
    for cleaner in [clean_git_commit, clean_gh_command]:
        cleaned = cleaner(command)
        if cleaned is not None:
            output = {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "allow",
                    "updatedInput": {"command": cleaned},
                }
            }
            json.dump(output, sys.stdout)
            return 0

    return 0


if __name__ == "__main__":
    sys.exit(main())

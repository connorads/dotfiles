# /// script
# requires-python = ">=3.12"
# dependencies = ["pytest"]
# ///
"""Tests for no-self-attribution hook."""

import importlib.util
import json
import subprocess
import sys
import tempfile
from pathlib import Path

import pytest

# Import the module under test (filename has hyphens)
_spec = importlib.util.spec_from_file_location(
    "no_self_attribution", Path(__file__).parent / "no-self-attribution.py"
)
assert _spec and _spec.loader
_mod = importlib.util.module_from_spec(_spec)
_spec.loader.exec_module(_mod)
check_git_commit = _mod.check_git_commit
check_gh_command = _mod.check_gh_command


# --- check_git_commit ---


class TestCheckGitCommit:
    @pytest.mark.parametrize(
        "command",
        [
            'git commit -m "feat: stuff\nCo-Authored-By: Claude <noreply@anthropic.com>"',
            'git commit -m "feat: stuff\nCo-Authored-By: claude <noreply@anthropic.com>"',
            'git commit -m "feat: stuff\nCo-Authored-By: Anthropic <noreply@anthropic.com>"',
            'git commit --message="feat: stuff\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"',
            'dotfiles commit -m "feat: stuff\nCo-Authored-By: Claude <noreply@anthropic.com>"',
            'git commit -m "feat" --trailer "Co-Authored-By: Claude <noreply@anthropic.com>"',
        ],
    )
    def test_blocks_attribution_in_command(self, command: str) -> None:
        result = check_git_commit(command)
        assert result is not None
        assert "Blocked" in result

    def test_blocks_attribution_in_file(self) -> None:
        with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
            f.write("feat: stuff\n\nCo-Authored-By: Claude <noreply@anthropic.com>\n")
            f.flush()
            result = check_git_commit(f"git commit -F {f.name}")
        assert result is not None
        assert "commit file" in result

    def test_blocks_file_flag_long_form(self) -> None:
        with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
            f.write("Co-Authored-By: Claude <noreply@anthropic.com>\n")
            f.flush()
            result = check_git_commit(f"git commit --file={f.name}")
        assert result is not None

    @pytest.mark.parametrize(
        "command",
        [
            'git commit -m "fix: stuff"',
            'git commit -m "fix: mention Claude in docs"',
            "git status",
            "ls -la",
        ],
    )
    def test_allows_safe_commands(self, command: str) -> None:
        assert check_git_commit(command) is None


# --- check_gh_command ---


class TestCheckGhCommand:
    @pytest.mark.parametrize(
        "command",
        [
            'gh pr create --body "Generated with [Claude Code](https://claude.ai)"',
            'gh pr create --body "Generated by Claude"',
            'gh pr create --body "\U0001f916 Claude Code"',
            'gh issue create --body "Generated with Claude"',
        ],
    )
    def test_blocks_attribution_in_command(self, command: str) -> None:
        result = check_gh_command(command)
        assert result is not None
        assert "Blocked" in result

    def test_blocks_attribution_in_body_file(self) -> None:
        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
            f.write("## Summary\n\n\U0001f916 Generated with [Claude Code]\n")
            f.flush()
            result = check_gh_command(f"gh pr create --title t --body-file {f.name}")
        assert result is not None
        assert "body file" in result

    @pytest.mark.parametrize(
        "command",
        [
            "gh pr view 123",
            'gh pr create --body "just a normal PR"',
        ],
    )
    def test_allows_safe_commands(self, command: str) -> None:
        assert check_gh_command(command) is None


# --- Integration test via subprocess ---


class TestIntegration:
    HOOK_PATH = str(Path(__file__).parent / "no-self-attribution.py")

    def _run(self, tool_input_command: str) -> subprocess.CompletedProcess[str]:
        payload = json.dumps({"tool_input": {"command": tool_input_command}})
        return subprocess.run(
            [sys.executable, self.HOOK_PATH],
            input=payload,
            capture_output=True,
            text=True,
        )

    def test_blocks_via_subprocess(self) -> None:
        r = self._run('git commit -m "x\nCo-Authored-By: Claude <noreply@anthropic.com>"')
        assert r.returncode == 2
        assert "Blocked" in r.stderr

    def test_allows_via_subprocess(self) -> None:
        r = self._run('git commit -m "fix: stuff"')
        assert r.returncode == 0

    def test_empty_command(self) -> None:
        r = self._run("")
        assert r.returncode == 0

    def test_invalid_json(self) -> None:
        r = subprocess.run(
            [sys.executable, self.HOOK_PATH],
            input="not json",
            capture_output=True,
            text=True,
        )
        assert r.returncode == 0

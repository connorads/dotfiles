#!/usr/bin/env zsh
# tsservedown: tear down a Tailscale serve/funnel port
# Usage: tsservedown [port]
#   <port>   → tear down that specific external HTTPS port
#   no args  → if one port served, tear it down; if multiple, fzf picker
emulate -L zsh

local serve_json
serve_json=$(ts serve status --json 2>/dev/null)

if [[ -z "$serve_json" || "$serve_json" == "null" || "$serve_json" == "{}" ]]; then
  print -u2 "no active serve config"
  return 0
fi

# Parse all served external ports
local -a eports
eports=("${(f)$(echo "$serve_json" | jq -r '.TCP // {} | keys[]' 2>/dev/null)}")

# Filter empty entries
local -a valid_ports
local _ep
for _ep in "${eports[@]}"; do
  [[ -n "$_ep" ]] && valid_ports+=("$_ep")
done
eports=("${valid_ports[@]}")

if [[ ${#eports[@]} -eq 0 ]]; then
  print -u2 "no active serve config"
  return 0
fi

# Helper: describe a served port
_tsserve_desc() {
  local ep=$1
  local proxy_url funnel=""
  local hostname
  hostname=$(ts-hostname 2>/dev/null)
  proxy_url=$(echo "$serve_json" | jq -r "
    .Web | to_entries[] | select(.key | endswith(\":$ep\")) |
    .value.Handlers // {} | to_entries[0].value.Proxy // \"unknown\"
  " 2>/dev/null)
  if echo "$serve_json" | jq -e ".AllowFunnel[\"$hostname:$ep\"] == true" >/dev/null 2>&1; then
    funnel=" (Funnel)"
  fi
  echo ":${ep}${funnel}  →  ${proxy_url:-unknown}"
}

# Direct mode: port given on command line
if [[ -n "$1" ]]; then
  if [[ ! "$1" =~ '^[0-9]+$' ]]; then
    print -u2 "usage: tsservedown [port]"
    unfunction _tsserve_desc 2>/dev/null
    return 1
  fi
  local desc
  desc=$(_tsserve_desc "$1")
  ts serve --https="$1" off || { unfunction _tsserve_desc 2>/dev/null; return 1; }
  echo "removed $desc"
  unfunction _tsserve_desc 2>/dev/null
  return 0
fi

# Auto mode: one port → auto-remove
if [[ ${#eports[@]} -eq 1 ]]; then
  local port="${eports[1]}"
  local desc
  desc=$(_tsserve_desc "$port")
  ts serve --https="$port" off || { unfunction _tsserve_desc 2>/dev/null; return 1; }
  echo "removed $desc"
  unfunction _tsserve_desc 2>/dev/null
  return 0
fi

# Multiple ports — fzf picker
local -a rows
local _hostname
_hostname=$(ts-hostname 2>/dev/null)
for _ep in "${eports[@]}"; do
  local proxy_url funnel_marker=""
  proxy_url=$(echo "$serve_json" | jq -r "
    .Web | to_entries[] | select(.key | endswith(\":$_ep\")) |
    .value.Handlers // {} | to_entries[0].value.Proxy // \"unknown\"
  " 2>/dev/null)
  if echo "$serve_json" | jq -e ".AllowFunnel[\"$_hostname:$_ep\"] == true" >/dev/null 2>&1; then
    funnel_marker="[Funnel] "
  fi
  rows+=("$(printf '%-7s %s→  %s' "$_ep" "$funnel_marker" "${proxy_url:-unknown}")")
done

local header="  PORT   TARGET
  select port to tear down"

local selection
selection=$(printf '%s\n' "${rows[@]}" | fzf --reverse --header="$header")
[[ -z "$selection" ]] && { unfunction _tsserve_desc 2>/dev/null; return 0; }

local chosen_port
chosen_port=$(echo "$selection" | awk '{print $1}')

ts serve --https="$chosen_port" off || { unfunction _tsserve_desc 2>/dev/null; return 1; }
echo "removed :$chosen_port"
unfunction _tsserve_desc 2>/dev/null
